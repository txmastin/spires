#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <math.h>
#include "reservoir.h"


void generate_noisy_sine_wave(double *buffer, size_t length, double freq, double sample_rate, double noise_gain) 
{
    for (size_t i = 0; i < length; i++) {
        double clean_signal = sin(2.0 * M_PI * freq * i / sample_rate);
        double noise = (noise_gain * rand() / RAND_MAX) - (noise_gain / 2.0);
        buffer[i] =  clean_signal + noise;
    }
}

void generate_mackey_glass(double *buffer, size_t length, double x0, double tau, double beta, double gamma, int n) 
{
    double mg_dt = 1.0;
    // Calculate the required length of the history buffer in discrete steps
    int history_len = (int)ceil(tau / mg_dt);

    // Allocate and initialize the history buffer
    double *history = malloc(history_len * sizeof(double));
    if (history == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for Mackey-Glass history.\n");
        return;
    }
    for (int i = 0; i < history_len; i++) {
        history[i] = x0;
    }

    buffer[0] = x0;
    double x_t = x0; // Current value of x

    for (size_t i = 0; i < length - 1; i++) {
        // Get the delayed value x(t - tau) from the history buffer
        double x_tau = history[i % history_len];

        // k1: slope at the beginning of the interval
        double k1 = mg_dt * (beta * x_tau / (1.0 + pow(x_tau, n)) - gamma * x_t);

        // k2: slope at the midpoint, using k1
        x_tau = history[(i + history_len / 2) % history_len]; // Approx. delay for midpoint
        double k2 = mg_dt * (beta * x_tau / (1.0 + pow(x_tau, n)) - gamma * (x_t + 0.5 * k1));

        // k3: slope at the midpoint, using k2
        double k3 = mg_dt * (beta * x_tau / (1.0 + pow(x_tau, n)) - gamma * (x_t + 0.5 * k2));

        // k4: slope at the end of the interval, using k3
        x_tau = history[(i + 1) % history_len]; // Approx. delay for endpoint
        double k4 = mg_dt * (beta * x_tau / (1.0 + pow(x_tau, n)) - gamma * (x_t + k3));

        // Update the current value using the weighted average of the slopes
        x_t += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0;

        // Store the new value in the history buffer (for future delayed lookups)
        history[(i + 1) % history_len] = x_t;

        // Store the new value in the output buffer
        buffer[i + 1] = x_t;
    }

    free(history);
}

int main(void) 
{
    srand(time(NULL));
    FILE *output_file = fopen("data/output_signals.dat", "w");

    if (output_file == NULL) {
        fprintf(stderr, "Error: Could not open data files for writing.\n");
        return 1;
    }
    
    /*
    // Generate input sine wave
    size_t timesteps = 50;
    double freq = 0.05;
    double sample_rate = 1.0;  
    double *input_series = malloc(timesteps * sizeof(double);
    double noise_gain = 3.0;

    generate_noisy_sine_wave(input_series, timesteps, freq, sample_rate, noise_gain);
    */

    // Generate chaotic mackey-glass signal
    // Parameters for chaotic behavior
    size_t timesteps = 200;
    double x0 = 0.1;
    double tau = 20; // Must be > 17 for chaos
    double beta = 0.2;
    double gamma = 0.1;
    int n = 10;

    // Allocate buffer for the output
    double *input_series = malloc(timesteps * sizeof(double));
    if (input_series == NULL) {
        return 1;
    }

    // Generate the series
    generate_mackey_glass(input_series, timesteps, x0, tau, beta, gamma, n);

    double *temp = &input_series[5];
    double *target_series = input_series;
    input_series = temp; 
    double series_length = timesteps-5;
    double lambda = 0.01;
    
    // training type
    enum training_type {
        RIDGE,
        ITERATIVE,
    };
    enum training_type training = RIDGE;
    
    // reservoir parameters 
    size_t num_neurons = 400;
    size_t num_inputs = 1;
    size_t num_outputs = 1;
    double rho = 0.99;
    double ei_ratio = 0.8;
    double input_strength = 1.0;
    double connectivity = 0.2;
    double dt = 0.1;
    enum neuron_type neuron_type = FLIF_GL;
    enum connectivity_type connectivity_type = RANDOM;
 
    // neuron parameters
    double fractional_neuron_params[] = {
        1.0,    // params[0]: V_th
        0.0,    // params[1]: V_reset
        0.0,    // params[2]: V_rest
        20.0,   // params[3]: tau_m
        0.7,    // params[4]: alpha
        dt,     // params[5]: dt
        timesteps,   // params[6]: Tmem
        0.1     // params[7]: bias
    };

    double discrete_neuron_params[] = {
        0.0, // params[0]: V_0
        1.0, // params[1]: V_th
        0.2, // params[2]: leak_rate
        0.05 // params[3]: bias
    };
    
    double *neuron_params = NULL;
    switch(neuron_type) {
        case LIF_DISCRETE:
            neuron_params = discrete_neuron_params;
            break;
        case FLIF_DIFFUSIVE:
            neuron_params = fractional_neuron_params;
            break;
        default:
            fprintf(stderr, "Error: Could not initialize neuron parameters, neuron type unavailable.\n");
            break;
    };
            
    
    // Create reservoir
    struct reservoir *res = create_reservoir(num_neurons, num_inputs, num_outputs, rho, ei_ratio, 
                                            input_strength, connectivity, dt, connectivity_type, 
                                            neuron_type, neuron_params);
    init_reservoir(res); 
    // run training and inferencing

    switch(training) {
        case RIDGE:
            train_output_ridge_regression(res, input_series, target_series, series_length, lambda); 
            break;
        case ITERATIVE:
        { // Use braces to create a new scope for local variables
            float lr = 0.01;
            int num_epochs = 1000;

            // Get these from the reservoir struct
            size_t num_inputs = res->num_inputs;
            size_t num_outputs = res->num_outputs;

            // Allocate a temporary array to hold the prediction for error calculation
            double prediction[num_outputs];

            for (int epoch = 0; epoch < num_epochs; epoch++) {
                double total_epoch_error = 0.0;

                // You might want to reset the reservoir state before each epoch
                reset_reservoir(res);

                for (size_t i = 0; i < series_length; i++) {
                    // 1. Get pointers to the current input and target vectors
                    const double *current_input = &input_series[i * num_inputs];
                    const double *current_target = &target_series[i * num_outputs];

                    // 2. Step the reservoir and train with the vectors
                    step_reservoir(res, current_input);
                    train_output_iteratively(res, current_target, lr);

                    // 3. Calculate the error for this timestep
                    compute_output(res, prediction);
                    for (size_t j = 0; j < num_outputs; j++) {
                        double error_for_output_j = prediction[j] - current_target[j];
                        total_epoch_error += fabs(error_for_output_j);
                    }
                }

                // Calculate the average error per output per timestep
                double avg_err = total_epoch_error / (series_length * num_outputs);
                printf("Average error for epoch %d: %f\n", epoch, avg_err);
            }
            break;
        }
    }
    reset_reservoir(res); // necessary for fractional neurons 
    

    double *reservoir_outputs = run_reservoir(res, input_series, series_length); 
    
    // saving final inference output of the reservoir
    fprintf(output_file, "# Timestep Input_Signal Reservoir_Output\n");
    for (size_t i = 0; i < series_length; i++) {
        fprintf(output_file, "%zu %f %f\n", i, input_series[i], reservoir_outputs[i]);
    }

    free_reservoir(res);
    fclose(output_file);

    return 0;
}


